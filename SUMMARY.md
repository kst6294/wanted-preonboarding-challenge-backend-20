## 프로젝트 요약


### 기술 스택

JAVA 21, SPRING BOOT 3.3, SPRING SECURITY, REDIS, JPA, QUERY DSL 5.0, JWT, EASY RANDOM, MYSQL, H2

### 개발 명세서 및 포스트맨 컬렉션

개발 명세서 : /src/main/resources/static/docs/index.html
포스트맨 컬랙션 : /src/main/resources/static/WANTED_MARKET_API.postman_collection.json

다운받아서 실행하면 됩니다.


### 기능 구현 리스트
DEVELOPMENT.md에 서술

1. 스프링 시큐리티를 사용하여 인증/인가 
2. 상품 등록/수정 
3. 상품 조회 
4. 상품 리스트 조회 
5. 주문 생성
6. 주문 수정
7. 주문 이력 조회
8. 주문 리스트 조회


### 회고

1. 리스트 조회 -> 노오프셋 조회
   1. 대용량 데이터일때 페이지가 뒤로갈수록 성능이 느려지기 떄문에 리스트 조회는 노오프셋으로 구현
   2. Slice를 커스텀 하여 lastDomainId 필드 제공(기준 키)
2. 주문 상태에 따른 전략 패턴
   1. 실제 운영 환경엔 수많은 주문 상태(배송중, 배송완료, 반품 등..) 가 있고 그 주문마다 해야할 특정 로직들이 존재
   2. 하지만 공통적으로 주문을 업데이트 하는 기능은 똑같다 -> 전략 패턴과 템플릿 패턴을 사용해 주문을 업데이트 하는 템플릿을 두고 특정 주문상태에 따라 동적으로 주문을 처리할 서비스 제공
   3. 결과적으로 하나의 서비스는 하나의 책임만 갖게 된다.
   4. 주문 상태 업데이트를 검증 하는 코드 또한 전략패턴으로 관리 
   5. 주문상태가 많아진다면 이걸 if 문으로 분기처리하기엔 가독성도 떨어지고 유지보수성도 떨어짐
3. 주문 동시성 문제
   1. 레디스를 사용한 분산락을 통해 동시성 제어
   2. 다만 여러 요청이 빠르게 계속 들어올 경우 1,2,3 에서 2번째 요청에서 분산락에 걸려 실패처리가 되었는데 그 사이 1번 분산락이 해제되어 2번보다 늦게 요청한 3번이 결제 성공할 수 있음
   3. 해당 문제는 메세지 큐(카프카 or 레빗 엠큐) 또는 웹소캣 통신과 레디스에 대기열을 만들어 해결할 수 있을것 같아 마지막 브랜치에서 해당 프로젝트에서 구현 중 기능 삭제 -> 완성도가 떨어질거같음  
   4. 다만 위의 기술스택을 사용했을때 상품이 품절이라면 이 품절 에러에 대한 핸들링을 어떻게 해야할까는 고민해봐야함
4. 테스트 객체 생성
   1. 목 데이터를 빠르게 생성하기 위해 EasyRandom 을 사용함
   2. 테스트를 위한 객체를 마더오브 패턴을 사용하여 한곳에서 관리하여 추후 코드의 유지보수성을 높임
   3. 일단 만들어 놓기만하면 100개든 1000개든 랜덤으로 빠르게 생성 할 수 있어 용이함
   4. 다만 이렇게 테스트를 위한 코드가 생성되고 이것 또한 관리 포인트가 된다는 점이 아쉬움
5. JPA vs 성능
   1. 각 엔티티들에 대해 연관관계를 맺고 최대한 JPA를 활용하여 비즈니스 로직을 가져감
   2. 유지보수와 가독성이 좋으나 성능에 대해선 생각해볼 필요가 있음
      1. 엔티티를 조회 후 더티체킹을 통한 업데이트 vs DTO로 필요한 필드만 뽑은 후 jdbcTemplate을 사용한 업데이트
      2. 나중에 서비스가 커졌을때 MSA로 구조로 가고 모듈 별로 DB가 나뉜다면 각 엔티티는 연관된 엔티티의 pkId만 필드로 갖게 되지 않을까 란 생각
6. 조회는 무조건 QueryDsl사용
   1. JpaRepository 를 사용하지 않고 QueryDsl 로 조회를 한 이유는 JpaRepository를 사용하게 될 경우 메서드명이 너무 길고 복잡한 쿼리는 가독성이 너무 떨어짐
7. 스프링 레스트 닥스
   1. 스프링 레스트 닥스를 사용하여 테스트 코드를 작성하고 빌드에 성공하면 저절로 snippets 파일이 생성되어 이걸 통해 adoc을 만들어 명세서에 휴먼 에러 확률 낮춤
   2. API 명세가 바뀌더라도 테스트 코드를 작성 후 빌드 하면 문서가 새롭게 계속 갱신 됨 (resource/static/docs/index.html)
8. 편의성 제공
   1. 협업을 좀 더 편리하게 하기 위해 서버가 시작될때 init/DataInitializer를 통해 데이터를 생성하게 함
   2. 포스트맨 컬렉션 제공
   3. 호스트/api/v1/docs를 통해 문서 접근 가능

